const express = require('express');
const bodyParser = require('body-parser');
const fs = require('fs').promises;
const path = require('path');
const { TelegramClient, Api } = require('telegram');
const { StringSession } = require('telegram/sessions');
const { Logger } = require('telegram/extensions/Logger');

// Desativar logging detalhado do Telegram.js, apenas erros e warnings
Logger.setLevel('warn');

const app = express();
const PORT = process.env.PORT || 3000;
const CONFIG_FILE = 'config.json';

// --- Middleware ---
app.use(bodyParser.json());
app.use(express.static(path.join(__dirname, 'public')));

// --- Mapa para armazenar inst√¢ncias de clientes Telegram e seus estados de autentica√ß√£o por sessionId ---
const clientSessions = new Map(); // key: sessionId, value: { client: TelegramClient, authState: { phoneCodeHash, sentCode, phoneNumber, passwordNeeded } }

// --- Fun√ß√µes de Leitura/Escrita do JSON ---
async function readConfig() {
    try {
        const data = await fs.readFile(CONFIG_FILE, 'utf8');
        return JSON.parse(data);
    } catch (error) {
        if (error.code === 'ENOENT') {
            console.log('‚ÑπÔ∏è Arquivo de configura√ß√£o n√£o encontrado. Criando um novo.');
            return { apiId: null, apiHash: null, sessionString: '' };
        }
        console.error('‚ùå Erro ao ler o arquivo de configura√ß√£o:', error);
        return { apiId: null, apiHash: null, sessionString: '' };
    }
}

async function saveConfig(config) {
    try {
        await fs.writeFile(CONFIG_FILE, JSON.stringify(config, null, 2));
        console.log('üíæ Configura√ß√µes salvas em config.json');
    } catch (error) {
        console.error('‚ùå Erro ao salvar o arquivo de configura√ß√£o:', error);
    }
}

// --- Rotas da API ---

// Rota para carregar as configura√ß√µes (API ID, API Hash, Session String)
app.get('/api/config', async (req, res) => {
    const config = await readConfig();
    res.json({
        apiId: config.apiId,
        apiHash: config.apiHash,
        sessionString: config.sessionString
    });
});

// Rota para salvar as configura√ß√µes (API ID, API Hash)
app.post('/api/config', async (req, res) => {
    const { apiId, apiHash } = req.body;
    if (!apiId || !apiHash) {
        return res.status(400).json({ success: false, message: 'API ID e API Hash s√£o obrigat√≥rios.' });
    }

    let config = await readConfig();
    config.apiId = parseInt(apiId, 10);
    config.apiHash = apiHash;

    await saveConfig(config);
    res.json({ success: true, message: 'Configura√ß√µes salvas com sucesso!' });
});

// Rota para iniciar o login (passo 1: enviar n√∫mero de telefone)
app.post('/api/auth/send-phone', async (req, res) => {
    const { phoneNumber, sessionId } = req.body;
    const config = await readConfig();
    const { apiId, apiHash } = config;

    if (!apiId || !apiHash) {
        return res.status(400).json({ success: false, message: 'API ID e API Hash n√£o configurados.' });
    }
    if (!phoneNumber) {
        return res.status(400).json({ success: false, message: 'N√∫mero de telefone √© obrigat√≥rio.' });
    }

    if (config.sessionString) {
        try {
            // Se o cliente conectou e n√£o houve erro, a sess√£o √© v√°lida
            console.log(`‚úÖ Login direto bem-sucedido com sess√£o existente (sess√£o ${sessionId}).`);
            res.json({ success: true, message: 'Login bem-sucedido com sess√£o existente!', step: 'completed', sessionString: config.sessionString });
            return; // Encerra aqui se a sess√£o √© v√°lida
        } catch (e) {
            // Se a sess√£o existente falhou, continua com o fluxo normal
            console.warn(`Sess√£o existente inv√°lida para ${sessionId}. Iniciando novo login.`);
        }
    }

    // Se j√° existe uma sess√£o para este client, desconecta e remove
    if (clientSessions.has(sessionId)) {
        const existingClient = clientSessions.get(sessionId).client;
        if (existingClient.connected) {
            await existingClient.disconnect();
        }
        clientSessions.delete(sessionId);
        console.log(`Sess√£o antiga ${sessionId} limpa.`);
    }

    const client = new TelegramClient(
        new StringSession(config.sessionString || ''),
        apiId,
        apiHash,
        { connectionRetries: 5 }
    );
    clientSessions.set(sessionId, { client, authState: { phoneNumber: phoneNumber } });

    try {
        await client.connect();

        // Tenta fazer o login com a sess√£o existente primeiro
        if (config.sessionString) {
            try {
                // Se o cliente conectou e n√£o houve erro, a sess√£o √© v√°lida
                console.log(`‚úÖ Login direto bem-sucedido com sess√£o existente (sess√£o ${sessionId}).`);
                res.json({ success: true, message: 'Login bem-sucedido com sess√£o existente!', step: 'completed', sessionString: config.sessionString });
                return; // Encerra aqui se a sess√£o √© v√°lida
            } catch (e) {
                // Se a sess√£o existente falhou, continua com o fluxo normal
                console.warn(`Sess√£o existente inv√°lida para ${sessionId}. Iniciando novo login.`);
            }
        }

        // Se n√£o usou sess√£o existente ou falhou, inicia o fluxo de envio de c√≥digo
        const result = await client.invoke(
            new Api.auth.SendCode({
                phoneNumber: phoneNumber,
                apiId: apiId,
                apiHash: apiHash,
                settings: new Api.CodeSettings({
                    allowFlashCall: false, // Desabilitar chamada flash
                    currentNumber: false,
                    allowAppHash: false // Desabilitar hash de app
                }),
            })
        );

        clientSessions.get(sessionId).authState.phoneCodeHash = result.phoneCodeHash;
        clientSessions.get(sessionId).authState.sentCode = result; // Guarda o objeto completo para next_type

        console.log(`C√≥digo de verifica√ß√£o enviado para ${phoneNumber} (sess√£o ${sessionId}).`);
        res.json({ success: true, message: 'C√≥digo de verifica√ß√£o enviado. Por favor, insira-o.', step: 'phoneCode' });

    } catch (error) {
        console.error(`‚ùå Erro ao enviar n√∫mero para ${phoneNumber} (sess√£o ${sessionId}):`, error.message);
        // Desconecta o cliente em caso de erro para liberar recursos
        if (client.connected) {
            await client.disconnect();
        }
        clientSessions.delete(sessionId);
        res.status(500).json({ success: false, message: `Erro ao enviar n√∫mero: ${error.message}` });
    }
});

// Nova rota para enviar c√≥digo de verifica√ß√£o
app.post('/api/auth/send-code', async (req, res) => {
    const { phoneCode, sessionId } = req.body;
    const clientState = clientSessions.get(sessionId);

    if (!clientState || !clientState.client || !clientState.authState.phoneCodeHash) {
        return res.status(400).json({ success: false, message: 'Sess√£o de autentica√ß√£o inv√°lida ou ausente. Por favor, comece novamente.' });
    }
    if (!phoneCode) {
        return res.status(400).json({ success: false, message: 'C√≥digo de verifica√ß√£o √© obrigat√≥rio.' });
    }

    const { client, authState } = clientState;
    const { phoneNumber, phoneCodeHash } = authState;

    try {
        const result = await client.invoke(
            new Api.auth.SignIn({
                phoneNumber: phoneNumber,
                phoneCodeHash: phoneCodeHash,
                phoneCode: phoneCode,
            })
        );

        const config = await readConfig();
        const newSessionString = client.session.save();
        config.sessionString = newSessionString;
        await saveConfig(config);

        console.log(`‚úÖ Login completo com c√≥digo (sess√£o ${sessionId}).`);
        res.json({ success: true, message: 'Login bem-sucedido!', step: 'completed', sessionString: newSessionString });

    } catch (error) {
        console.error(`‚ùå Erro ao enviar c√≥digo (sess√£o ${sessionId}):`, error.message);
        if (error.className === 'SessionPasswordNeededError') {
            clientState.authState.passwordNeeded = true; // Sinaliza que a senha √© necess√°ria
            res.json({ success: true, message: 'Senha 2FA necess√°ria. Por favor, forne√ßa a senha.', step: 'password' });
        } else {
            // Desconecta o cliente em caso de erro no c√≥digo
            if (client.connected) {
                await client.disconnect();
            }
            clientSessions.delete(sessionId);
            res.status(500).json({ success: false, message: `Erro no c√≥digo de verifica√ß√£o: ${error.message}` });
        }
    }
});

// Nova rota para enviar senha 2FA
app.post('/api/auth/send-password', async (req, res) => {
    const { password, sessionId } = req.body;
    const clientState = clientSessions.get(sessionId);

    if (!clientState || !clientState.client || !clientState.authState.phoneCodeHash) {
        return res.status(400).json({ success: false, message: 'Sess√£o de autentica√ß√£o inv√°lida ou ausente. Por favor, comece novamente.' });
    }
    if (!password) {
        return res.status(400).json({ success: false, message: 'Senha √© obrigat√≥ria.' });
    }

    const { client, authState } = clientState;
    const { phoneNumber, phoneCodeHash } = authState; // Ainda precisamos deles para o sign-in final

    try {
        const result = await client.invoke(
            new Api.auth.CheckPassword({
                password: password,
            })
        );

        const config = await readConfig();
        const newSessionString = client.session.save();
        config.sessionString = newSessionString;
        await saveConfig(config);

        console.log(`‚úÖ Senha 2FA aceita, login completo (sess√£o ${sessionId}).`);
        res.json({ success: true, message: 'Login bem-sucedido!', step: 'completed', sessionString: newSessionString });

    } catch (error) {
        console.error(`‚ùå Erro ao enviar senha (sess√£o ${sessionId}):`, error.message);
        // Desconecta o cliente em caso de erro na senha
        if (client.connected) {
            await client.disconnect();
        }
        clientSessions.delete(sessionId);
        res.status(500).json({ success: false, message: `Erro na senha 2FA: ${error.message}` });
    }
});

// Rota para listar grupos
app.get('/api/groups', async (req, res) => {
    const config = await readConfig();
    const apiId = config.apiId;
    const apiHash = config.apiHash;
    const sessionString = config.sessionString;

    if (!apiId || !apiHash || !sessionString) {
        return res.status(400).json({ success: false, message: 'Credenciais ou sess√£o n√£o configuradas. Por favor, configure-as e autentique-se.' });
    }

    // Criar um novo cliente para esta opera√ß√£o espec√≠fica, usando a sess√£o persistida
    const client = new TelegramClient(new StringSession(sessionString), apiId, apiHash, {
        connectionRetries: 5,
    });

    try {
        await client.connect();
        if (!client.connected) {
            // Tenta se conectar, se falhar, sugere re-autentica√ß√£o
            return res.status(500).json({ success: false, message: 'Falha ao conectar ao Telegram. A sess√£o pode estar inv√°lida. Tente autenticar novamente.' });
        }

        const dialogs = await client.getDialogs({});
        const groups = dialogs
            .filter(dialog => dialog.isGroup)
            .map(dialog => ({
                id: dialog.id.toString(),
                title: dialog.title,
                isArchived: dialog.isArchived,
                isChannel: dialog.isChannel,
                unreadCount: dialog.unreadCount
            }));
        res.json({ success: true, groups });
    } catch (error) {
        console.error('‚ùå Erro ao listar grupos:', error);
        res.status(500).json({ success: false, message: `Erro ao listar grupos: ${error.message}. A sess√£o pode ter expirado. Tente autenticar novamente.` });
    } finally {
        if (client.connected) {
            await client.disconnect();
        }
    }
});

app.post('/api/leave-groups', async (req, res) => {
    // groupIds agora ser√° um array de objetos: [{id: '...', peerType: 'channel'}, {id: '...', peerType: 'chat'}]
    const { groupIds } = req.body; // Renomeado para clareza

    console.log('Sair de grupos:', groupIds);
    
    if (!Array.isArray(groupIds) || groupIds.length === 0) {
        return res.status(400).json({ success: false, message: 'IDs de grupos inv√°lidos ou vazios.' });
    }

    const config = await readConfig();
    const apiId = config.apiId;
    const apiHash = config.apiHash;
    const sessionString = config.sessionString;

    if (!apiId || !apiHash || !sessionString) {
        return res.status(400).json({ success: false, message: 'Credenciais ou sess√£o n√£o configuradas.' });
    }

    const client = new TelegramClient(new StringSession(sessionString), apiId, apiHash, {
        connectionRetries: 5,
    });

    const results = [];

    try {
        await client.connect();
        if (!client.connected) {
            return res.status(500).json({ success: false, message: 'Falha ao conectar ao Telegram para sair de grupos. A sess√£o pode estar inv√°lida.' });
        }

        for (const groupInfo of groupIds) { // Itera sobre o array de objetos
            const { id: groupId, peerType } = groupInfo; // Desestrutura o id e o peerType
            console.log('Grupo ID:', groupId, 'Tipo:', peerType);
           
            try {
                let success = false;
                let message = '';

                if (peerType === 'channel') {
                    // Para canais e supergrupos
                    let channelId = parseInt(groupId.startsWith('-100') ? groupId.substring(4) : groupId, 10);
                    let peer = new Api.PeerChannel({ channelId: channelId });

                    await client.invoke(
                        new Api.channels.LeaveChannel({
                            channel: peer
                        })
                    );
                    success = true;
                    message = 'Saiu do canal/supergrupo.';
                } else if (peerType === 'chat') {
                    // Para grupos b√°sicos
                    let chatId = parseInt(groupId, 10);
                    // O id do chat deve ser positivo para PeerChat, mas dialog.id pode ser negativo.
                    // O telegram.js geralmente lida com isso se voc√™ passar dialog.entity.
                    // Se voc√™ est√° usando o ID diretamente, o PeerChat aceita o ID negativo sem o -100 prefixo.
                    // Ou se for um ID de chat que vem de dialog.id, ele j√° est√° formatado.
                    // A maneira mais segura √© pegar o dialog.entity original.
                    // Como n√£o estamos persistindo o dialog.entity, vamos tentar com PeerChat.
                    let peer = new Api.PeerChat({ chatId: chatId }); // Use o ID diretamente aqui

                    // Para sair de um grupo b√°sico, voc√™ remove a si mesmo do chat.
                    await client.invoke(
                        new Api.messages.DeleteChatUser({
                            chatId: chatId,
                            userId: new Api.InputUserSelf(), // Remove a si mesmo
                        })
                    );
                    success = true;
                    message = 'Saiu do grupo b√°sico.';
                } else {
                    message = `Tipo de grupo desconhecido para ID ${groupId}.`;
                }

                if (success) {
                    results.push({ id: groupId, status: 'Sucesso', message: message });
                } else {
                    results.push({ id: groupId, status: 'Falha', message: message });
                }

            } catch (error) {
                let errorMessage = `Erro ao sair do grupo ${groupId}: ${error.message}`;
                if (error.className === 'PeerIdInvalidError') {
                    errorMessage = `ID de grupo inv√°lido para ${groupId} ou voc√™ n√£o √© membro.`;
                } else if (error.className === 'ChannelPrivateError' || error.className === 'ChatAdminRequiredError') {
                    errorMessage = `N√£o foi poss√≠vel sair do grupo ${groupId}: acesso negado (pode ser um chat privado, voc√™ n√£o √© membro, ou permiss√£o necess√°ria).`;
                } else if (error.className === 'UserBotBlockedError') {
                    errorMessage = `O bot foi bloqueado no grupo ${groupId}.`;
                } else if (error.className === 'ChatIdInvalidError' && peerType === 'chat') {
                    // Isso pode acontecer se o ID do chat b√°sico estiver incorreto ou o chat n√£o existir mais.
                    errorMessage = `ID de grupo b√°sico inv√°lido para ${groupId}.`;
                } else if (error.className === 'CHANNEL_INVALID') {
                     errorMessage = `CHANNEL_INVALID para ${groupId}. Provavelmente o ID ou tipo de peer est√° incorreto.`;
                }
                console.error(errorMessage);
                results.push({ id: groupId, status: 'Falha', message: errorMessage });
            }
        }
        res.json({ success: true, results });

    } catch (error) {
        console.error('‚ùå Erro na opera√ß√£o de sa√≠da de grupos:', error);
        res.status(500).json({ success: false, message: `Erro geral ao sair de grupos: ${error.message}` });
    } finally {
        if (client.connected) {
            await client.disconnect();
        }
    }
});

// ... (Resto do c√≥digo) ...
// Rota para deslogar
app.post('/api/logout', async (req, res) => {
    let config = await readConfig();
    config.sessionString = ''; // Limpa a sess√£o
    await saveConfig(config);
    // Limpa tamb√©m o cliente Telegram associado a esta sess√£o, se existir
    const { sessionId } = req.body;
    if (sessionId && clientSessions.has(sessionId)) {
        const clientState = clientSessions.get(sessionId);
        if (clientState.client.connected) {
            await clientState.client.disconnect();
        }
        clientSessions.delete(sessionId);
        console.log(`Sess√£o de cliente ${sessionId} removida.`);
    }
    res.json({ success: true, message: 'Sess√£o limpa com sucesso. Por favor, recarregue a p√°gina.' });
});


// --- Iniciar Servidor ---
app.listen(PORT, () => {
    console.log(`Servidor rodando em http://localhost:${PORT}`);
    console.log('Acesse seu navegador para configurar as credenciais do Telegram e interagir.');
});